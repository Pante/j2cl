// Generated from "intersectiontype/IntersectionTypeTest.java"
@file:OptIn(ExperimentalObjCName::class)
@file:Suppress(
 "ALWAYS_NULL",
 "PARAMETER_NAME_CHANGED_ON_OVERRIDE",
 "SENSELESS_COMPARISON",
 "UNCHECKED_CAST",
 "UNNECESSARY_LATEINIT",
 "UNNECESSARY_NOT_NULL_ASSERTION",
 "UNREACHABLE_CODE",
 "UNUSED_ANONYMOUS_PARAMETER",
 "UNUSED_PARAMETER",
 "UNUSED_VARIABLE",
 "USELESS_CAST",
 "VARIABLE_IN_SINGLETON_WITHOUT_THREAD_LOCAL",
 "VARIABLE_WITH_REDUNDANT_INITIALIZER",
 "REDUNDANT_ELSE_IN_WHEN")

package intersectiontype

import javaemul.lang.*
import kotlin.Any
import kotlin.Comparable
import kotlin.Int
import kotlin.OptIn
import kotlin.String
import kotlin.Suppress
import kotlin.experimental.ExperimentalObjCName
import kotlin.jvm.JvmStatic
import kotlin.let
import kotlin.native.ObjCName

@ObjCName(name = "J2ktIntersectiontypeGetable", swiftName = "IntersectiontypeGetable", exact = true)
fun interface Getable<T> {
 @ObjCName(name = "get")
 fun get(): T
}

@ObjCName(name = "J2ktIntersectiontypeSetable", swiftName = "IntersectiontypeSetable", exact = true)
fun interface Setable {
 @ObjCName(name = "set")
 fun set(
  @ObjCName(name = "withInt") i: Int
 )
}

@ObjCName(name = "J2ktIntersectiontypeSerial", swiftName = "IntersectiontypeSerial", exact = true)
interface Serial

@ObjCName(name = "J2ktIntersectiontypeCmp", swiftName = "IntersectiontypeCmp", exact = true)
fun interface Cmp {
 @ObjCName(name = "cmp")
 fun cmp(): Int

 @ObjCName(name = "defaultM")
 fun defaultM(): Int {
  return 1
 }
}

@ObjCName(name = "J2ktIntersectiontypeCmp2", swiftName = "IntersectiontypeCmp2", exact = true)
fun interface Cmp2<T> {
 @ObjCName(name = "cmp")
 fun cmp(
  @ObjCName(name = "withInt") a: Int
 ): Int
}

@ObjCName(name = "J2ktIntersectiontypeCmpImpl", swiftName = "IntersectiontypeCmpImpl", exact = true)
open class CmpImpl internal constructor(): Cmp {
 override fun cmp(): Int {
  return 1
 }
}

@ObjCName(name = "J2ktIntersectiontypeIntersectionTypeTest", swiftName = "IntersectiontypeIntersectionTypeTest", exact = true)
open class IntersectionTypeTest<U> {
 @ObjCName(name = "cast3")
 open fun cast3(
  @ObjCName(name = "withId") s: Any?
 ): Any? {
  return s
 }

 @ObjCName(name = "testMethodCall")
 open fun testMethodCall() {
  val o: Any? = IntersectionTypeTest.m/* <IntersectionTypeTest.A? & IntersectionTypeTest.EmptyA?> */()
  IntersectionTypeTest.set/* <IntersectionTypeTest.A? & IntersectionTypeTest.EmptyA?> */(
   o.let { it as IntersectionTypeTest.A?; it as IntersectionTypeTest.EmptyA?; it },
  )
  IntersectionTypeTest.set/* <IntersectionTypeTest.A? & IntersectionTypeTest.EmptyA?> */(
   IntersectionTypeTest.m/* <IntersectionTypeTest.A? & IntersectionTypeTest.EmptyA?> */(),
  )
  val g: Getable<*>? = IntersectionTypeTest.n/* <IntersectionTypeTest.A? & IntersectionTypeTest.EmptyA?> */()
 }

 @ObjCName(name = "testDefaultMethodCall")
 open fun testDefaultMethodCall(
  @ObjCName(name = "withId") o: Any?
 ) {
  o.let { it as Cmp?; it as IntersectionTypeTest.EmptyA?; it }!!.defaultM()
  o.let { it as CmpImpl?; it as IntersectionTypeTest.EmptyA?; it }!!.defaultM()
 }

 @ObjCName(name = "J2ktIntersectiontypeIntersectionTypeTestCompanion", swiftName = "IntersectiontypeIntersectionTypeTestCompanion", exact = true)
 companion object {
  @JvmStatic
  @ObjCName(name = "getAndSet")
  fun <T> getAndSet(
   @ObjCName(name = "withId") `object`: T
  ) where T: Getable<*>?, T: Setable? {
   `object`!!.set(1)
   `object`!!.get()
  }

  @JvmStatic
  @ObjCName(name = "cast")
  fun <T> cast(
   @ObjCName(name = "withId") o: Any?
  ): Getable<T>? {
   if (o == null) {
    return o.let { it as Getable<T>?; it as Setable?; it }
   }
   return o.let { it as Getable<T>?; it as Setable?; it }
  }

  @JvmStatic
  @ObjCName(name = "cast1")
  fun <T> cast1(
   @ObjCName(name = "withId") s: Any?
  ): Getable<Comparable<String>?>? {
   return s.let { it as Getable<Comparable<String>?>?; it as Setable?; it }
  }

  @JvmStatic
  @ObjCName(name = "cast2")
  fun <T> cast2(
   @ObjCName(name = "withId") s: Any?
  ): Getable<Comparable<T & Any>?>? {
   return s.let { it as Getable<Comparable<T & Any>?>?; it as Setable?; it }
  }

  @JvmStatic
  @ObjCName(name = "method")
  fun method(): Cmp? {
   return (Cmp {
    return@Cmp 1
   }).let { it as Cmp; it as Serial; it }
  }

  @JvmStatic
  @ObjCName(name = "method2")
  fun method2(): Cmp2<Any?>? {
   return Cmp2<Any?> { a: Int ->
    return@Cmp2 1
   } as Cmp2<Any?>?
  }

  @JvmStatic
  @ObjCName(name = "testClosureAssignment")
  fun testClosureAssignment(
   @ObjCName(name = "withId") o: Any?
  ) {
   val e: IntersectionTypeTest.A? = o.let { it as IntersectionTypeTest.A?; it as IntersectionTypeTest.EmptyA?; it as IntersectionTypeTest.EmptyB?; it }
   val g: IntersectionTypeTest.EmptyA? = o.let { it as IntersectionTypeTest.A?; it as IntersectionTypeTest.EmptyA?; it as IntersectionTypeTest.EmptyB?; it }
   val s: IntersectionTypeTest.EmptyB? = o.let { it as IntersectionTypeTest.A?; it as IntersectionTypeTest.EmptyA?; it as IntersectionTypeTest.EmptyB?; it }
  }

  @JvmStatic
  private fun <T> get(t: T): T {
   return t
  }

  @JvmStatic
  private fun <T> m(): T where T: IntersectionTypeTest.A?, T: IntersectionTypeTest.EmptyA? {
   return IntersectionTypeTest.get<Any?>(
    Any(),
   ) as T
  }

  @JvmStatic
  private fun <T> n(): Getable<T>? where T: IntersectionTypeTest.A?, T: IntersectionTypeTest.EmptyA? {
   return null
  }

  @JvmStatic
  private fun <T> set(t: T) where T: IntersectionTypeTest.A?, T: IntersectionTypeTest.EmptyA? {}

  @JvmStatic
  private fun <T> callOnIntersetionTypes(t: T) where T: IntersectionTypeTest.SomeConcreteType?, T: Cmp? {
   t!!.cmp()
   null.let { it as IntersectionTypeTest.SomeConcreteType?; it as Cmp?; it }!!.cmp()
  }

  @JvmStatic
  private fun <T> callOnIntersectionTypeWithParameterizedType(t: T) where T: IntersectionTypeTest.GenericType<String?>?, T: Getable<Int?>? {
   t!!.doSomething_pp_intersectiontype("")
   t!!.get()
  }

  @JvmStatic
  private fun callOnIntersectionTypeWithRawType() {
   val t /* IntersectionTypeTest.GenericType<Any?>? & Getable<Any?>? */ = IntersectionTypeTest.GenericType<String?>().let { it as IntersectionTypeTest.GenericType<Any?>; it as Getable<Any?>; it }
   (t!! as IntersectionTypeTest.GenericType<Any?>).doSomething_pp_intersectiontype("")
   (t!! as Getable<Any?>).get()
  }
 }

 @ObjCName(name = "J2ktIntersectiontypeIntersectionTypeTest_MapEntry", swiftName = "IntersectiontypeIntersectionTypeTest_MapEntry", exact = true)
 open inner class MapEntry internal constructor() {
  @ObjCName(name = "method")
  open fun <T> method(
   @ObjCName(name = "withId") o: Any?
  ): Getable<T>? {
   return o.let { it as Getable<T>?; it as Setable?; it }
  }
 }

 @ObjCName(name = "J2ktIntersectiontypeIntersectionTypeTest_A", swiftName = "IntersectiontypeIntersectionTypeTest_A", exact = true)
 open class A internal constructor()

 @ObjCName(name = "J2ktIntersectiontypeIntersectionTypeTest_EmptyA", swiftName = "IntersectiontypeIntersectionTypeTest_EmptyA", exact = true)
 interface EmptyA

 @ObjCName(name = "J2ktIntersectiontypeIntersectionTypeTest_EmptyB", swiftName = "IntersectiontypeIntersectionTypeTest_EmptyB", exact = true)
 interface EmptyB

 @ObjCName(name = "J2ktIntersectiontypeIntersectionTypeTest_SomeConcreteType", swiftName = "IntersectiontypeIntersectionTypeTest_SomeConcreteType", exact = true)
 open class SomeConcreteType internal constructor()

 @ObjCName(name = "J2ktIntersectiontypeIntersectionTypeTest_GenericType", swiftName = "IntersectiontypeIntersectionTypeTest_GenericType", exact = true)
 open class GenericType<T> internal constructor() {
  internal open fun doSomething_pp_intersectiontype(t: T) {}
 }
}
