// Generated from "bridgemethods/BridgeMethod.java"
@file:OptIn(ExperimentalObjCName::class)
@file:Suppress(
 "ALWAYS_NULL",
 "PARAMETER_NAME_CHANGED_ON_OVERRIDE",
 "SENSELESS_COMPARISON",
 "UNCHECKED_CAST",
 "UNNECESSARY_LATEINIT",
 "UNNECESSARY_NOT_NULL_ASSERTION",
 "UNREACHABLE_CODE",
 "UNUSED_ANONYMOUS_PARAMETER",
 "UNUSED_PARAMETER",
 "UNUSED_VARIABLE",
 "USELESS_CAST",
 "VARIABLE_IN_SINGLETON_WITHOUT_THREAD_LOCAL",
 "VARIABLE_WITH_REDUNDANT_INITIALIZER",
 "REDUNDANT_ELSE_IN_WHEN")

package bridgemethods

import javaemul.lang.*
import jsinterop.annotations.JsType
import kotlin.Any
import kotlin.AssertionError
import kotlin.Comparable
import kotlin.Double
import kotlin.Error
import kotlin.Number
import kotlin.OptIn
import kotlin.String
import kotlin.Suppress
import kotlin.experimental.ExperimentalObjCName
import kotlin.native.ObjCName

@ObjCName(name = "J2ktBridgemethodsSomeInterface", swiftName = "BridgemethodsSomeInterface", exact = true)
interface SomeInterface<T, S> {
 @ObjCName(name = "foo")
 fun foo(
  @ObjCName(name = "withId") t: T,
  @ObjCName(name = "withId") s: S
 )

 @ObjCName(name = "foo")
 fun foo(
  @ObjCName(name = "withId") t: T,
  @ObjCName(name = "withNSNumber") n: Number?
 )
}

@ObjCName(name = "J2ktBridgemethodsSuperParent", swiftName = "BridgemethodsSuperParent", exact = true)
open class SuperParent<T, S> internal constructor() {
 @ObjCName(name = "foo")
 open fun foo(
  @ObjCName(name = "withId") t: T,
  @ObjCName(name = "withId") s: S
 ) {}
}

@ObjCName(name = "J2ktBridgemethodsParent", swiftName = "BridgemethodsParent", exact = true)
open class Parent<T: Error?> internal constructor(): SuperParent<T, Number?>() {
 override fun foo(t: T, s: Number?) {}

 @ObjCName(name = "bar")
 open fun <T_1: Number?> bar(
  @ObjCName(name = "withNSNumber") t: T_1
 ) {}

 @ObjCName(name = "fun")
 open fun <T_1> `fun`(
  @ObjCName(name = "withId") t: T_1
 ) {}
}

@ObjCName(name = "J2ktBridgemethodsBridgeMethod", swiftName = "BridgemethodsBridgeMethod", exact = true)
open class BridgeMethod: Parent<AssertionError?>(), SomeInterface<AssertionError?, Number?> {
 override fun foo(a: AssertionError?, n: Number?) {}

 @ObjCName(name = "fun")
 open fun `fun`(
  @ObjCName(name = "withNSNumber") t: Number?
 ) {}
}

@ObjCName(name = "J2ktBridgemethodsSomeOtherFooInterface", swiftName = "BridgemethodsSomeOtherFooInterface", exact = true)
fun interface SomeOtherFooInterface<T> {
 @ObjCName(name = "foo")
 fun foo(
  @ObjCName(name = "withId") t: T,
  @ObjCName(name = "withJavaLangDouble") s: Double?
 )
}

@ObjCName(name = "J2ktBridgemethodsDualUnrelatedBridges", swiftName = "BridgemethodsDualUnrelatedBridges", exact = true)
open class DualUnrelatedBridges internal constructor(): SomeInterface<String?, Double?>, SomeOtherFooInterface<String?> {
 override fun foo(s: String?, n: Double?) {}

 override fun foo(s: String?, n: Number?) {}
}

@ObjCName(name = "J2ktBridgemethodsSuperDualUnrelatedAccidentalBridges", swiftName = "BridgemethodsSuperDualUnrelatedAccidentalBridges", exact = true)
open class SuperDualUnrelatedAccidentalBridges internal constructor() {
 @ObjCName(name = "foo")
 open fun foo(
  @ObjCName(name = "withNSString") s: String?,
  @ObjCName(name = "withJavaLangDouble") n: Double?
 ) {}

 @ObjCName(name = "foo")
 open fun foo(
  @ObjCName(name = "withNSString") s: String?,
  @ObjCName(name = "withNSNumber") n: Number?
 ) {}
}

@ObjCName(name = "J2ktBridgemethodsDualUnrelatedAccidentalBridges", swiftName = "BridgemethodsDualUnrelatedAccidentalBridges", exact = true)
open class DualUnrelatedAccidentalBridges internal constructor(): SuperDualUnrelatedAccidentalBridges(), SomeInterface<String?, Double?>, SomeOtherFooInterface<String?>

@ObjCName(name = "J2ktBridgemethodsGetter", swiftName = "BridgemethodsGetter", exact = true)
fun interface Getter {
 @ObjCName(name = "get")
 fun get(
  @ObjCName(name = "withNSString") s: String?
 ): String?
}

@ObjCName(name = "J2ktBridgemethodsClassWithParameterizedGet", swiftName = "BridgemethodsClassWithParameterizedGet", exact = true)
open class ClassWithParameterizedGet<T> internal constructor() {
 @ObjCName(name = "get")
 open fun get(
  @ObjCName(name = "withId") t: T
 ): T {
  return null as T
 }
}

@ObjCName(name = "J2ktBridgemethodsAccidentalOverrideBridge", swiftName = "BridgemethodsAccidentalOverrideBridge", exact = true)
open class AccidentalOverrideBridge internal constructor(): ClassWithParameterizedGet<String?>(), Getter {
 @ObjCName(name = "test")
 open fun test() {
  val g: Getter = AccidentalOverrideBridge()
  g.get("")
 }
}

@ObjCName(name = "J2ktBridgemethodsTestCase10036", swiftName = "BridgemethodsTestCase10036", exact = true)
open class TestCase10036 internal constructor() {
 @ObjCName(name = "J2ktBridgemethodsTestCase10036_BI3", swiftName = "BridgemethodsTestCase10036_BI3", exact = true)
 @JsType
 interface BI3 {
  @ObjCName(name = "get")
  fun get(
   @ObjCName(name = "withNSString") value: String?
  ): String? {
   return "BI3 get String"
  }
 }

 @ObjCName(name = "J2ktBridgemethodsTestCase10036_BI2", swiftName = "BridgemethodsTestCase10036_BI2", exact = true)
 fun interface BI2 {
  @ObjCName(name = "get")
  fun get(
   @ObjCName(name = "withNSString") value: String?
  ): String?
 }

 @ObjCName(name = "J2ktBridgemethodsTestCase10036_BI1", swiftName = "BridgemethodsTestCase10036_BI1", exact = true)
 fun interface BI1: TestCase10036.BI3 {
  override fun get(value: String?): String?
 }

 @ObjCName(name = "J2ktBridgemethodsTestCase10036_B", swiftName = "BridgemethodsTestCase10036_B", exact = true)
 abstract class B<B1: Comparable<*>?> internal constructor(): TestCase10036.BI1, TestCase10036.BI2 {
  @ObjCName(name = "get")
  abstract fun get(
   @ObjCName(name = "withJavaLangComparable") value: B1
  ): String?
 }
}

@ObjCName(name = "J2ktBridgemethodsTestCase102", swiftName = "BridgemethodsTestCase102", exact = true)
open class TestCase102 internal constructor() {
 @ObjCName(name = "J2ktBridgemethodsTestCase102_BI2", swiftName = "BridgemethodsTestCase102_BI2", exact = true)
 @JsType
 fun interface BI2 {
  @ObjCName(name = "set")
  fun set(
   @ObjCName(name = "withNSString") value: String?
  )
 }

 @ObjCName(name = "J2ktBridgemethodsTestCase102_BI1", swiftName = "BridgemethodsTestCase102_BI1", exact = true)
 fun interface BI1 {
  @ObjCName(name = "set")
  fun set(
   @ObjCName(name = "withNSString") value: String?
  )
 }

 @ObjCName(name = "J2ktBridgemethodsTestCase102_B", swiftName = "BridgemethodsTestCase102_B", exact = true)
 abstract class B<B1> internal constructor(): TestCase102.BI1, TestCase102.BI2 {
  @ObjCName(name = "set")
  abstract fun set(
   @ObjCName(name = "withId") value: B1
  )
 }

 @ObjCName(name = "J2ktBridgemethodsTestCase102_C", swiftName = "BridgemethodsTestCase102_C", exact = true)
 open inner class C<B1> internal constructor(): TestCase102.B<B1>() {
  override fun set(value: String?) {}

  override fun set(value: B1) {}
 }
}

@ObjCName(name = "J2ktBridgemethodsParameterizedParent", swiftName = "BridgemethodsParameterizedParent", exact = true)
open class ParameterizedParent<T: ParameterizedParent<T>?> internal constructor() {
 internal open fun <Q: T> m_pp_bridgemethods(t: Q): Q {
  return null as Q
 }
}

@ObjCName(name = "J2ktBridgemethodsReparametrerizedChild", swiftName = "BridgemethodsReparametrerizedChild", exact = true)
open class ReparametrerizedChild<E: ReparametrerizedChild<E>?> internal constructor(): ParameterizedParent<E>() {
 override fun <S: E> m_pp_bridgemethods(t: S): S {
  return null as S
 }
}

@ObjCName(name = "J2ktBridgemethodsLeafChild", swiftName = "BridgemethodsLeafChild", exact = true)
open class LeafChild internal constructor(): ReparametrerizedChild<LeafChild?>()

@ObjCName(name = "J2ktBridgemethodsStringConsumer", swiftName = "BridgemethodsStringConsumer", exact = true)
fun interface StringConsumer {
 @ObjCName(name = "accept")
 fun accept(
  @ObjCName(name = "withNSString") s: String?
 )
}

@ObjCName(name = "J2ktBridgemethodsConsumer", swiftName = "BridgemethodsConsumer", exact = true)
open class Consumer<T> internal constructor() {
 @ObjCName(name = "accept")
 fun accept(
  @ObjCName(name = "withId") t: T
 ) {}
}

@ObjCName(name = "J2ktBridgemethodsStringConsumerImpl", swiftName = "BridgemethodsStringConsumerImpl", exact = true)
open class StringConsumerImpl internal constructor(): Consumer<String?>(), StringConsumer

@ObjCName(name = "J2ktBridgemethodsSpecializingReturnAbstractClass", swiftName = "BridgemethodsSpecializingReturnAbstractClass", exact = true)
abstract class SpecializingReturnAbstractClass internal constructor() {
 @ObjCName(name = "foo")
 abstract fun foo(): Any?
}

@ObjCName(name = "J2ktBridgemethodsSpecializingReturnInterface", swiftName = "BridgemethodsSpecializingReturnInterface", exact = true)
fun interface SpecializingReturnInterface {
 @ObjCName(name = "foo")
 fun foo(): String?
}

@ObjCName(name = "J2ktBridgemethodsSpecializingReturnAbstractSubclass", swiftName = "BridgemethodsSpecializingReturnAbstractSubclass", exact = true)
abstract class SpecializingReturnAbstractSubclass internal constructor(): SpecializingReturnAbstractClass(), SpecializingReturnInterface

@ObjCName(name = "J2ktBridgemethodsInterfaceWithDefaultMethod", swiftName = "BridgemethodsInterfaceWithDefaultMethod", exact = true)
interface InterfaceWithDefaultMethod {
 @ObjCName(name = "foo")
 fun foo(): Any? {
  return "A"
 }
}

@ObjCName(name = "J2ktBridgemethodsInterfaceOverridingDefaultMethod", swiftName = "BridgemethodsInterfaceOverridingDefaultMethod", exact = true)
fun interface InterfaceOverridingDefaultMethod: InterfaceWithDefaultMethod {
 override fun foo(): String?
}

@ObjCName(name = "J2ktBridgemethodsDoesNotInheritDefaultMethod1", swiftName = "BridgemethodsDoesNotInheritDefaultMethod1", exact = true)
abstract class DoesNotInheritDefaultMethod1 internal constructor(): InterfaceWithDefaultMethod, InterfaceOverridingDefaultMethod

@ObjCName(name = "J2ktBridgemethodsDoesNotInheritDefaultMethod2", swiftName = "BridgemethodsDoesNotInheritDefaultMethod2", exact = true)
abstract class DoesNotInheritDefaultMethod2 internal constructor(): InterfaceOverridingDefaultMethod, InterfaceWithDefaultMethod

@ObjCName(name = "J2ktBridgemethodsPackagePrivateBridgeSuper", swiftName = "BridgemethodsPackagePrivateBridgeSuper", exact = true)
open class PackagePrivateBridgeSuper<T, U> internal constructor() {
 internal open fun <S: T, R: PackagePrivateBridgeSuper<S, R>?> m_pp_bridgemethods(r: R, s: S, t: T, u: U) {}
}

@ObjCName(name = "J2ktBridgemethodsPackagePrivateBridge", swiftName = "BridgemethodsPackagePrivateBridge", exact = true)
class PackagePrivateBridge<V, W> internal constructor(): PackagePrivateBridgeSuper<V, W>() {
 @ObjCName(name = "m")
 public fun <S: V, R: PackagePrivateBridgeSuper<S, R>?> m(
  @ObjCName(name = "withBridgemethodsPackagePrivateBridgeSuper") r: R,
  @ObjCName(name = "withId") s: S,
  @ObjCName(name = "withId") v: V,
  @ObjCName(name = "withId") w: W
 ) {}

 override fun <S: V, R: PackagePrivateBridgeSuper<S, R>?> m_pp_bridgemethods(arg0: R, arg1: S, arg2: V, arg3: W) {
  this.m(arg0, arg1, arg2, arg3)
 }
}
