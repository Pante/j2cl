// Generated from "j2kt/StreamCollectWildcardProblem.java"
@file:OptIn(ExperimentalObjCName::class)
@file:Suppress(
 "ALWAYS_NULL",
 "PARAMETER_NAME_CHANGED_ON_OVERRIDE",
 "SENSELESS_COMPARISON",
 "UNCHECKED_CAST",
 "UNNECESSARY_LATEINIT",
 "UNNECESSARY_NOT_NULL_ASSERTION",
 "UNREACHABLE_CODE",
 "UNUSED_ANONYMOUS_PARAMETER",
 "UNUSED_PARAMETER",
 "UNUSED_VARIABLE",
 "USELESS_CAST",
 "VARIABLE_IN_SINGLETON_WITHOUT_THREAD_LOCAL",
 "VARIABLE_WITH_REDUNDANT_INITIALIZER",
 "REDUNDANT_ELSE_IN_WHEN")

package j2kt

import javaemul.lang.*
import java.lang.RuntimeException
import java.util.Objects
import java.util.function.Function
import java.util.function.Predicate
import java.util.stream.Collector
import java.util.stream.Collectors
import java.util.stream.Stream
import kotlin.Any
import kotlin.Boolean
import kotlin.OptIn
import kotlin.String
import kotlin.Suppress
import kotlin.collections.MutableList
import kotlin.experimental.ExperimentalObjCName
import kotlin.jvm.JvmStatic
import kotlin.native.ObjCName

@ObjCName(name = "J2ktJ2ktStreamCollectWildcardProblem", swiftName = "J2ktStreamCollectWildcardProblem", exact = true)
open class StreamCollectWildcardProblem {
 @ObjCName(name = "J2ktJ2ktStreamCollectWildcardProblemCompanion", swiftName = "J2ktStreamCollectWildcardProblemCompanion", exact = true)
 companion object {
  @JvmStatic
  @ObjCName(name = "testCollect")
  fun testCollect(
   @ObjCName(name = "withJavaUtilStreamStream") list: Stream<StreamCollectWildcardProblem.Foo<*>>
  ) {
   StreamCollectWildcardProblem.accept(
    list.collect<MutableList<StreamCollectWildcardProblem.Foo<*>>, Any>(
     Collectors.toList<StreamCollectWildcardProblem.Foo<*>>() as Collector<in StreamCollectWildcardProblem.Foo<*>, Any, MutableList<StreamCollectWildcardProblem.Foo<*>>>,
    ),
   )
  }

  @JvmStatic
  @ObjCName(name = "testMethodReferenceMapCollect")
  fun testMethodReferenceMapCollect(
   @ObjCName(name = "withJavaUtilStreamStream") list: Stream<StreamCollectWildcardProblem.Foo<*>>
  ) {
   StreamCollectWildcardProblem.accept(
    list.map/* <StreamCollectWildcardProblem.Foo<*>> */(
     Function/* <in StreamCollectWildcardProblem.Foo<*>, out StreamCollectWildcardProblem.Foo<*>> */ { arg0: StreamCollectWildcardProblem.Foo<*> ->
      return@Function arg0.getThis() as StreamCollectWildcardProblem.Foo<*>
     },
    ).collect<MutableList<StreamCollectWildcardProblem.Foo<*>>, Any>(
     Collectors.toList<StreamCollectWildcardProblem.Foo<*>>() as Collector<in StreamCollectWildcardProblem.Foo<*>, Any, MutableList<StreamCollectWildcardProblem.Foo<*>>>,
    ),
   )
  }

  @JvmStatic
  @ObjCName(name = "testLambdaMapCollect")
  fun testLambdaMapCollect(
   @ObjCName(name = "withJavaUtilStreamStream") list: Stream<StreamCollectWildcardProblem.Foo<*>>
  ) {
   StreamCollectWildcardProblem.accept(
    list.map/* <StreamCollectWildcardProblem.Foo<*>> */(
     Function/* <in StreamCollectWildcardProblem.Foo<*>, out StreamCollectWildcardProblem.Foo<*>> */ { it: StreamCollectWildcardProblem.Foo<*> ->
      return@Function it.getThis() as StreamCollectWildcardProblem.Foo<*>
     },
    ).collect<MutableList<StreamCollectWildcardProblem.Foo<*>>, Any>(
     Collectors.toList<StreamCollectWildcardProblem.Foo<*>>() as Collector<in StreamCollectWildcardProblem.Foo<*>, Any, MutableList<StreamCollectWildcardProblem.Foo<*>>>,
    ),
   )
  }

  @JvmStatic
  @ObjCName(name = "testCollectWithExplicitTypeArgumentFix")
  fun testCollectWithExplicitTypeArgumentFix(
   @ObjCName(name = "withJavaUtilStreamStream") list: Stream<StreamCollectWildcardProblem.Foo<*>>
  ) {
   StreamCollectWildcardProblem.accept(
    list.collect/* <MutableList<StreamCollectWildcardProblem.Foo<*>>, *> */(
     Collectors.toList<StreamCollectWildcardProblem.Foo<*>>(),
    ),
   )
  }

  @JvmStatic
  @ObjCName(name = "testMethodReferenceMapCollectWithExplicitTypeArgumentFix")
  fun testMethodReferenceMapCollectWithExplicitTypeArgumentFix(
   @ObjCName(name = "withJavaUtilStreamStream") list: Stream<StreamCollectWildcardProblem.Foo<*>>
  ) {
   StreamCollectWildcardProblem.accept(
    list.map/* <StreamCollectWildcardProblem.Foo<*>> */(
     Function/* <in StreamCollectWildcardProblem.Foo<*>, out StreamCollectWildcardProblem.Foo<*>> */ { arg0: StreamCollectWildcardProblem.Foo<*> ->
      return@Function arg0.getThis() as StreamCollectWildcardProblem.Foo<*>
     },
    ).collect/* <MutableList<StreamCollectWildcardProblem.Foo<*>>, *> */(
     Collectors.toList<StreamCollectWildcardProblem.Foo<*>>() as Collector<in StreamCollectWildcardProblem.Foo<*>, *, MutableList<StreamCollectWildcardProblem.Foo<*>>>,
    ),
   )
  }

  @JvmStatic
  @ObjCName(name = "testLambdaMapCollectWithExplicitTypeArgumentFix")
  fun testLambdaMapCollectWithExplicitTypeArgumentFix(
   @ObjCName(name = "withJavaUtilStreamStream") list: Stream<StreamCollectWildcardProblem.Foo<*>>
  ) {
   StreamCollectWildcardProblem.accept(
    list.map/* <StreamCollectWildcardProblem.Foo<*>> */(
     Function/* <in StreamCollectWildcardProblem.Foo<*>, out StreamCollectWildcardProblem.Foo<*>> */ { it: StreamCollectWildcardProblem.Foo<*> ->
      return@Function it.getThis() as StreamCollectWildcardProblem.Foo<*>
     },
    ).collect/* <MutableList<StreamCollectWildcardProblem.Foo<*>>, *> */(
     Collectors.toList<StreamCollectWildcardProblem.Foo<*>>() as Collector<in StreamCollectWildcardProblem.Foo<*>, *, MutableList<StreamCollectWildcardProblem.Foo<*>>>,
    ),
   )
  }

  @JvmStatic
  @ObjCName(name = "accept")
  fun accept(
   @ObjCName(name = "withJavaUtilList") list: MutableList<StreamCollectWildcardProblem.Foo<*>>
  ) {
   throw RuntimeException()
  }

  @JvmStatic
  @ObjCName(name = "testNullabilityInference")
  fun testNullabilityInference(
   @ObjCName(name = "withJavaUtilStreamStream") stream1: Stream<StreamCollectWildcardProblem.Foo<Any>>,
   @ObjCName(name = "withJavaUtilStreamStream") stream2: Stream<StreamCollectWildcardProblem.Foo<Any>>,
   @ObjCName(name = "withBoolean") b: Boolean
  ): Stream<String> {
   return Stream.of<Stream<String>>(
    (if (b) stream1.map<String>(
     Function/* <in StreamCollectWildcardProblem.Foo<Any>, out String> */ { arg0: StreamCollectWildcardProblem.Foo<Any> ->
      return@Function arg0.getString()
     },
    ) else null)!!,
    (if (b) stream2.map<String>(
     Function/* <in StreamCollectWildcardProblem.Foo<Any>, out String> */ { arg0_1: StreamCollectWildcardProblem.Foo<Any> ->
      return@Function arg0_1.getString()
     },
    ) else null)!!,
   ).filter(
    Predicate/* <in Stream<String>> */ { arg0_2: Stream<String> ->
     return@Predicate Objects.nonNull(arg0_2)
    },
   ).flatMap<String>(
    Function/* <in Stream<String>, out Stream<out String>> */ { stream: Stream<String> ->
     return@Function stream
    },
   )
  }
 }

 @ObjCName(name = "J2ktJ2ktStreamCollectWildcardProblem_Foo", swiftName = "J2ktStreamCollectWildcardProblem_Foo", exact = true)
 interface Foo<T: Any> {
  @ObjCName(name = "getThis")
  fun getThis(): StreamCollectWildcardProblem.Foo<T>

  @ObjCName(name = "getString")
  fun getString(): String
 }
}
