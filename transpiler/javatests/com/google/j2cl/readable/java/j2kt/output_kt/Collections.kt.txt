// Generated from "j2kt/Collections.java"
@file:OptIn(ExperimentalObjCName::class)
@file:Suppress(
 "ALWAYS_NULL",
 "PARAMETER_NAME_CHANGED_ON_OVERRIDE",
 "SENSELESS_COMPARISON",
 "UNCHECKED_CAST",
 "UNNECESSARY_LATEINIT",
 "UNNECESSARY_NOT_NULL_ASSERTION",
 "UNREACHABLE_CODE",
 "UNUSED_ANONYMOUS_PARAMETER",
 "UNUSED_PARAMETER",
 "UNUSED_VARIABLE",
 "USELESS_CAST",
 "VARIABLE_IN_SINGLETON_WITHOUT_THREAD_LOCAL",
 "VARIABLE_WITH_REDUNDANT_INITIALIZER",
 "REDUNDANT_ELSE_IN_WHEN")

package j2kt

import javaemul.lang.*
import java.lang.IndexOutOfBoundsException
import java.lang.RuntimeException
import java.util.AbstractCollection
import java.util.AbstractList
import java.util.AbstractMap
import java.util.Spliterator
import javaemul.lang.MutableCollectionJvm
import javaemul.lang.MutableListJvm
import javaemul.lang.MutableMapJvm
import javaemul.lang.uninitializedArrayOf
import kotlin.Any
import kotlin.Array
import kotlin.Boolean
import kotlin.Int
import kotlin.OptIn
import kotlin.String
import kotlin.Suppress
import kotlin.collections.Collection
import kotlin.collections.Map
import kotlin.collections.MutableCollection
import kotlin.collections.MutableIterator
import kotlin.collections.MutableList
import kotlin.collections.MutableMap
import kotlin.collections.MutableMap.MutableEntry
import kotlin.collections.MutableSet
import kotlin.experimental.ExperimentalObjCName
import kotlin.jvm.JvmStatic
import kotlin.native.ObjCName

@ObjCName("J2ktJ2ktCollections", exact = true)
open class Collections {
 @ObjCName("J2ktJ2ktCollectionsCompanion", exact = true)
 companion object {
  @JvmStatic
  @ObjCName("testCollection_generic")
  fun <T> testCollection_generic(
   @ObjCName("withJavaUtilCollection") collection: MutableCollection<T>
  ) {
   collection.java_contains(
    Collections.generic<T>(),
   )
   collection.java_remove(
    Collections.generic<T>(),
   )
   collection.java_containsAll(
    Collections.genericCollection<T>(),
   )
   collection.java_addAll(
    Collections.genericCollection<T>(),
   )
   collection.java_removeAll(
    Collections.genericCollection<T>(),
   )
   collection.java_retainAll(
    Collections.genericCollection<T>(),
   )
   collection.java_contains(
    Collections.mismatching() as Any?,
   )
   collection.java_remove(
    Collections.mismatching() as Any?,
   )
   collection.java_containsAll(
    Collections.mismatchingCollection(),
   )
   collection.java_removeAll(
    Collections.mismatchingCollection(),
   )
   collection.java_retainAll(
    Collections.mismatchingCollection(),
   )
  }

  @JvmStatic
  @ObjCName("testCollection_parameterized")
  fun testCollection_parameterized(
   @ObjCName("withJavaUtilCollection") collection: MutableCollection<String>
  ) {
   collection.java_contains(
    Collections.string(),
   )
   collection.java_remove(
    Collections.string(),
   )
   collection.java_containsAll(
    Collections.collectionOfString(),
   )
   collection.java_addAll(
    Collections.collectionOfString(),
   )
   collection.java_removeAll(
    Collections.collectionOfString(),
   )
   collection.java_retainAll(
    Collections.collectionOfString(),
   )
   collection.java_contains(
    Collections.mismatching() as Any?,
   )
   collection.java_remove(
    Collections.mismatching() as Any?,
   )
   collection.java_containsAll(
    Collections.mismatchingCollection(),
   )
   collection.java_removeAll(
    Collections.mismatchingCollection(),
   )
   collection.java_retainAll(
    Collections.mismatchingCollection(),
   )
  }

  @JvmStatic
  @ObjCName("testCollection_specialized")
  fun testCollection_specialized(
   @ObjCName("withJ2ktCollections_CollectionOfString") collection: Collections.CollectionOfString
  ) {
   collection.java_contains(
    Collections.string(),
   )
   collection.java_remove(
    Collections.string(),
   )
   collection.java_containsAll(
    Collections.collectionOfString(),
   )
   collection.java_addAll(
    Collections.collectionOfString(),
   )
   collection.java_removeAll(
    Collections.collectionOfString(),
   )
   collection.java_retainAll(
    Collections.collectionOfString(),
   )
   collection.java_contains(
    Collections.mismatching() as Any?,
   )
   collection.java_remove(
    Collections.mismatching() as Any?,
   )
   collection.java_containsAll(
    Collections.mismatchingCollection(),
   )
   collection.java_removeAll(
    Collections.mismatchingCollection(),
   )
   collection.java_retainAll(
    Collections.mismatchingCollection(),
   )
  }

  @JvmStatic
  @ObjCName("testList_generic")
  fun <T> testList_generic(
   @ObjCName("withJavaUtilList") list: MutableList<T>
  ) {
   list.java_addAll(
    0,
    Collections.genericCollection<T>(),
   )
   list.java_indexOf(
    Collections.generic<T>(),
   )
   list.java_lastIndexOf(
    Collections.generic<T>(),
   )
   list.java_indexOf(
    Collections.mismatching() as Any?,
   )
   list.java_lastIndexOf(
    Collections.mismatching() as Any?,
   )
  }

  @JvmStatic
  @ObjCName("testList_parameterized")
  fun testList_parameterized(
   @ObjCName("withJavaUtilList") list: MutableList<String>
  ) {
   list.java_addAll(
    0,
    Collections.collectionOfString(),
   )
   list.java_indexOf(
    Collections.string(),
   )
   list.java_lastIndexOf(
    Collections.string(),
   )
   list.java_indexOf(
    Collections.mismatching() as Any?,
   )
   list.java_lastIndexOf(
    Collections.mismatching() as Any?,
   )
  }

  @JvmStatic
  @ObjCName("testList_specialized")
  fun testList_specialized(
   @ObjCName("withJ2ktCollections_ListOfString") list: Collections.ListOfString
  ) {
   list.java_addAll(
    0,
    Collections.collectionOfString(),
   )
   list.java_indexOf(
    Collections.string(),
   )
   list.java_lastIndexOf(
    Collections.string(),
   )
   list.java_indexOf(
    Collections.mismatching() as Any?,
   )
   list.java_lastIndexOf(
    Collections.mismatching() as Any?,
   )
  }

  @JvmStatic
  @ObjCName("testMap_generic")
  fun <K, V> testMap_generic(
   @ObjCName("withJavaUtilMap") map: MutableMap<K, V>
  ) {
   map.java_get(
    Collections.generic<K>(),
   )
   map.java_getOrDefault(
    Collections.generic<K>(),
    Collections.generic<V?>(),
   )
   map.java_containsKey(
    Collections.generic<K>(),
   )
   map.java_containsValue(
    Collections.generic<V>(),
   )
   map.java_putAll(
    Collections.genericMap<K, V>(),
   )
   map.java_remove(
    Collections.generic<K>(),
   )
   map.java_remove(
    Collections.generic<K>(),
    Collections.generic<V>(),
   )
   map.java_get(
    Collections.mismatching() as Any?,
   )
   map.java_getOrDefault(
    Collections.mismatching() as Any?,
    Collections.generic<V?>(),
   )
   map.java_containsKey(
    Collections.mismatching() as Any?,
   )
   map.java_containsValue(
    Collections.mismatching() as Any?,
   )
   map.java_remove(
    Collections.mismatching() as Any?,
   )
   map.java_remove(
    Collections.mismatching() as Any?,
    Collections.mismatching() as Any?,
   )
  }

  @JvmStatic
  @ObjCName("testMap_parameterized")
  fun testMap_parameterized(
   @ObjCName("withJavaUtilMap") map: MutableMap<String, String>
  ) {
   map.java_get(
    Collections.string(),
   )
   map.java_getOrDefault(
    Collections.string(),
    Collections.string(),
   )
   map.java_containsKey(
    Collections.string(),
   )
   map.java_containsValue(
    Collections.string(),
   )
   map.java_putAll(
    Collections.mapOfString(),
   )
   map.java_remove(
    Collections.string(),
   )
   map.java_remove(
    Collections.string(),
    Collections.string(),
   )
   map.java_get(
    Collections.mismatching() as Any?,
   )
   map.java_getOrDefault(
    Collections.mismatching() as Any?,
    Collections.string(),
   )
   map.java_containsKey(
    Collections.mismatching() as Any?,
   )
   map.java_containsValue(
    Collections.mismatching() as Any?,
   )
   map.java_remove(
    Collections.mismatching() as Any?,
   )
   map.java_remove(
    Collections.mismatching() as Any?,
    Collections.mismatching() as Any?,
   )
  }

  @JvmStatic
  @ObjCName("testMap_specialized")
  fun testMap_specialized(
   @ObjCName("withJ2ktCollections_MapOfString") map: Collections.MapOfString
  ) {
   map.java_get(
    Collections.string(),
   )
   map.java_getOrDefault(
    Collections.string(),
    Collections.string(),
   )
   map.java_containsKey(
    Collections.string(),
   )
   map.java_containsValue(
    Collections.string(),
   )
   map.java_putAll(
    Collections.mapOfString(),
   )
   map.java_remove(
    Collections.string(),
   )
   map.java_remove(
    Collections.string(),
    Collections.string(),
   )
   map.java_get(
    Collections.mismatching() as Any?,
   )
   map.java_getOrDefault(
    Collections.mismatching() as Any?,
    Collections.string(),
   )
   map.java_containsKey(
    Collections.mismatching() as Any?,
   )
   map.java_containsValue(
    Collections.mismatching() as Any?,
   )
   map.java_remove(
    Collections.mismatching() as Any?,
   )
   map.java_remove(
    Collections.mismatching() as Any?,
    Collections.mismatching() as Any?,
   )
  }

  @JvmStatic
  private fun <T> convert(`object`: T): T {
   return `object`
  }

  @JvmStatic
  private fun <T> convertCollection(c: MutableCollection<T>): MutableCollection<T> {
   return c
  }

  @JvmStatic
  private fun <K, V> convertMap(m: MutableMap<K, V>): MutableMap<K, V> {
   return m
  }

  @JvmStatic
  private fun <T> generic(): T {
   throw RuntimeException()
  }

  @JvmStatic
  private fun string(): String {
   throw RuntimeException()
  }

  @JvmStatic
  private fun mismatching(): Int {
   throw RuntimeException()
  }

  @JvmStatic
  private fun <T> genericCollection(): MutableCollection<T> {
   throw RuntimeException()
  }

  @JvmStatic
  private fun collectionOfString(): MutableCollection<String> {
   throw RuntimeException()
  }

  @JvmStatic
  private fun mismatchingCollection(): MutableCollection<Int> {
   throw RuntimeException()
  }

  @JvmStatic
  private fun <K, V> genericMap(): MutableMap<K, V> {
   throw RuntimeException()
  }

  @JvmStatic
  private fun mapOfString(): MutableMap<String, String> {
   throw RuntimeException()
  }
 }

 @ObjCName("J2ktJ2ktCollections_CustomCollection", exact = true)
 open class CustomCollection<T>: AbstractCollection<T>() {
  override fun iterator(): MutableIterator<T> {
   throw RuntimeException()
  }

  override val size: Int
   get() {
    return 0
   }

  override fun contains(o: T): Boolean {
   var o_1: Any? = o
   o_1 = Collections.convert<Any?>(o_1)
   return super<AbstractCollection>.contains(
    o_1 as T,
   )
  }

  override fun remove(o: T): Boolean {
   var o_1: Any? = o
   o_1 = Collections.convert<Any?>(o_1)
   return super<AbstractCollection>.remove(
    o_1 as T,
   )
  }

  override fun addAll(c: Collection<T>): Boolean {
   var c_1: MutableCollection<out T> = c as MutableCollection<out T>
   c_1 = Collections.convertCollection/* <capture#1-of out T> */(c_1)
   return super<AbstractCollection>.addAll(
    c_1 as Collection<T>,
   )
  }

  override fun containsAll(c: Collection<T>): Boolean {
   var c_1: MutableCollection<*> = c as MutableCollection<*>
   c_1 = Collections.convertCollection/* <capture#2-of out Any> */(c_1)
   return super<AbstractCollection>.containsAll(
    c_1 as Collection<T>,
   )
  }

  override fun removeAll(c: Collection<T>): Boolean {
   var c_1: MutableCollection<*> = c as MutableCollection<*>
   c_1 = Collections.convertCollection/* <capture#3-of out Any> */(c_1)
   return super<AbstractCollection>.removeAll(
    c_1 as Collection<T>,
   )
  }

  override fun retainAll(c: Collection<T>): Boolean {
   var c_1: MutableCollection<*> = c as MutableCollection<*>
   c_1 = Collections.convertCollection/* <capture#4-of out Any> */(c_1)
   return super<AbstractCollection>.retainAll(
    c_1 as Collection<T>,
   )
  }

  override fun toArray(): Array<Any?> {
   return super<AbstractCollection>.toArray()
  }

  override fun <T1> toArray(a: Array<T1>): Array<T1> {
   return super<AbstractCollection>.toArray<T1>(a)
  }
 }

 @ObjCName("J2ktJ2ktCollections_CustomCollectionDisambiguatingOverrides", exact = true)
 open class CustomCollectionDisambiguatingOverrides<T>: Collections.CustomCollection<T>(), MutableCollectionJvm<T> {
  override fun spliterator(): Spliterator<T> {
   return super<Collections.CustomCollection>.spliterator()
  }
 }

 @ObjCName("J2ktJ2ktCollections_CustomList", exact = true)
 open class CustomList<T>: AbstractList<T>() {
  override fun get(index: Int): T {
   throw IndexOutOfBoundsException()
  }

  override val size: Int
   get() {
    return 0
   }

  override fun addAll(index: Int, c: Collection<T>): Boolean {
   var c_1: MutableCollection<out T> = c as MutableCollection<out T>
   c_1 = Collections.convertCollection/* <capture#5-of out T> */(c_1)
   return super<AbstractList>.addAll(
    index,
    c_1 as Collection<T>,
   )
  }

  override fun indexOf(o: T): Int {
   var o_1: Any? = o
   o_1 = Collections.convert<Any?>(o_1)
   return super<AbstractList>.indexOf(
    o_1 as T,
   )
  }

  override fun lastIndexOf(o: T): Int {
   var o_1: Any? = o
   o_1 = Collections.convert<Any?>(o_1)
   return super<AbstractList>.lastIndexOf(
    o_1 as T,
   )
  }

  override fun toArray(): Array<Any?> {
   return super<AbstractList>.toArray()
  }

  override fun <T1> toArray(a: Array<T1>): Array<T1> {
   return super<AbstractList>.toArray<T1>(a)
  }
 }

 @ObjCName("J2ktJ2ktCollections_CustomMap", exact = true)
 open class CustomMap<K, V>: AbstractMap<K, V>() {
  override val entries: MutableSet<MutableEntry<K, V>>
   get() {
    throw RuntimeException()
   }

  override fun containsKey(key: K): Boolean {
   var key_1: Any? = key
   key_1 = Collections.convert<Any?>(key_1)
   return super<AbstractMap>.containsKey(
    key_1 as K,
   )
  }

  override fun containsValue(value: V): Boolean {
   var value_1: Any? = value
   value_1 = Collections.convert<Any?>(value_1)
   return super<AbstractMap>.containsValue(
    value_1 as V,
   )
  }

  override fun remove(key: K): V? {
   var key_1: Any? = key
   key_1 = Collections.convert<Any?>(key_1)
   return super<AbstractMap>.remove(
    key_1 as K,
   )
  }

  override fun remove(key: K, value: V): Boolean {
   var value_1: Any? = value
   var key_1: Any? = key
   key_1 = Collections.convert<Any?>(key_1)
   value_1 = Collections.convert<Any?>(value_1)
   return super<AbstractMap>.remove(
    key_1 as K,
    value_1 as V,
   )
  }

  override fun get(key: K): V? {
   var key_1: Any? = key
   key_1 = Collections.convert<Any?>(key_1)
   return super<AbstractMap>.get(
    key_1 as K,
   )
  }

  override fun getOrDefault(key: K, defaultValue: V): V {
   val defaultValue_1: V? = defaultValue
   var key_1: Any? = key
   key_1 = Collections.convert<Any?>(key_1)
   return super<AbstractMap>.getOrDefault(
    key_1 as K,
    defaultValue_1 as V,
   ) as V
  }

  override fun putAll(m: Map<out K, V>) {
   var m_1: MutableMap<out K, out V> = m as MutableMap<out K, out V>
   m_1 = Collections.convertMap/* <capture#6-of out K, capture#7-of out V> */(m_1)
   super<AbstractMap>.putAll(
    m_1 as Map<out K, V>,
   )
  }
 }

 @ObjCName("J2ktJ2ktCollections_CustomMapDisambiguatingOverrides", exact = true)
 abstract class CustomMapDisambiguatingOverrides<K, V>: Collections.CustomMap<K, V>(), MutableMapJvm<K, V> {
  override fun getOrDefault(arg0: K, arg1: V): V {
   val arg1_1: V? = arg1
   val arg0_1: Any? = arg0
   return super<Collections.CustomMap>.getOrDefault(
    arg0_1 as K,
    arg1_1 as V,
   ) as V
  }

  override fun remove(arg0: K, arg1: V): Boolean {
   val arg1_1: Any? = arg1
   val arg0_1: Any? = arg0
   return super<Collections.CustomMap>.remove(
    arg0_1 as K,
    arg1_1 as V,
   )
  }
 }

 @ObjCName("J2ktJ2ktCollections_CustomMapReturnTypes", exact = true)
 open class CustomMapReturnTypes<K, V>: Collections.CustomMap<K, V>() {
  override fun getOrDefault(key: K, defaultValue: V): V {
   val defaultValue_1: V? = defaultValue
   val key_1: Any? = key
   return defaultValue_1 as V
  }
 }

 @ObjCName("J2ktJ2ktCollections_CollectionOfString", exact = true)
 open class CollectionOfString: Collections.CustomCollection<String>() {
  @ObjCName("containsInteger")
  open fun containsInteger(
   @ObjCName("withJavaLangInteger") integer: Int
  ): Boolean {
   return super<Collections.CustomCollection>.remove(
    integer as String,
   )
  }

  @ObjCName("removeInteger")
  open fun removeInteger(
   @ObjCName("withJavaLangInteger") integer: Int
  ): Boolean {
   return super<Collections.CustomCollection>.remove(
    integer as String,
   )
  }
 }

 @ObjCName("J2ktJ2ktCollections_ListOfString", exact = true)
 open class ListOfString: Collections.CustomList<String>() {
  override fun indexOf(o: String): Int {
   var o_1: Any? = o
   o_1 = Collections.convert<Any?>(o_1)
   return super<Collections.CustomList>.indexOf(
    o_1 as String,
   )
  }

  override fun lastIndexOf(o: String): Int {
   var o_1: Any? = o
   o_1 = Collections.convert<Any?>(o_1)
   return super<Collections.CustomList>.lastIndexOf(
    o_1 as String,
   )
  }
 }

 @ObjCName("J2ktJ2ktCollections_MapOfString", exact = true)
 open class MapOfString: Collections.CustomMap<String, String>() {
  override fun containsKey(key: String): Boolean {
   var key_1: Any? = key
   key_1 = Collections.convert<Any?>(key_1)
   return super<Collections.CustomMap>.containsKey(
    key_1 as String,
   )
  }

  override fun containsValue(value: String): Boolean {
   var value_1: Any? = value
   value_1 = Collections.convert<Any?>(value_1)
   return super<Collections.CustomMap>.containsValue(
    value_1 as String,
   )
  }

  override fun remove(key: String): String? {
   var key_1: Any? = key
   key_1 = Collections.convert<Any?>(key_1)
   return super<Collections.CustomMap>.remove(
    key_1 as String,
   )
  }

  override fun remove(key: String, value: String): Boolean {
   var value_1: Any? = value
   var key_1: Any? = key
   key_1 = Collections.convert<Any?>(key_1)
   value_1 = Collections.convert<Any?>(value_1)
   return super<Collections.CustomMap>.remove(
    key_1 as String,
    value_1 as String,
   )
  }

  override fun get(key: String): String? {
   var key_1: Any? = key
   key_1 = Collections.convert<Any?>(key_1)
   return super<Collections.CustomMap>.get(
    key_1 as String,
   )
  }

  override fun getOrDefault(key: String, defaultValue: String): String {
   val defaultValue_1: String? = defaultValue
   var key_1: Any? = key
   key_1 = Collections.convert<Any?>(key_1)
   return super<Collections.CustomMap>.getOrDefault(
    key_1 as String,
    defaultValue_1 as String,
   ) as String
  }
 }

 @ObjCName("J2ktJ2ktCollections_AbstractCollectionWithToArrayOverride", exact = true)
 abstract class AbstractCollectionWithToArrayOverride<E>: MutableCollectionJvm<E> {
  @Suppress("NOTHING_TO_OVERRIDE")
  override fun toArray(): Array<Any?> {
   return uninitializedArrayOf<Any>(0) as Array<Any?>
  }

  @Suppress("NOTHING_TO_OVERRIDE")
  override fun <T> toArray(a: Array<T>): Array<T> {
   return a
  }
 }

 @ObjCName("J2ktJ2ktCollections_CollectionInterfaceWithToArrayOverride", exact = true)
 interface CollectionInterfaceWithToArrayOverride<E>: MutableListJvm<E> {
  @Suppress("NOTHING_TO_OVERRIDE")
  override fun toArray(): Array<Any?>

  @Suppress("NOTHING_TO_OVERRIDE")
  override fun <T> toArray(a: Array<T>): Array<T>
 }
}
