// Generated from "j2kt/Collections.java"
@file:OptIn(ExperimentalObjCName::class)
@file:Suppress(
 "ALWAYS_NULL",
 "PARAMETER_NAME_CHANGED_ON_OVERRIDE",
 "SENSELESS_COMPARISON",
 "UNCHECKED_CAST",
 "UNNECESSARY_LATEINIT",
 "UNNECESSARY_NOT_NULL_ASSERTION",
 "UNREACHABLE_CODE",
 "UNUSED_ANONYMOUS_PARAMETER",
 "UNUSED_PARAMETER",
 "UNUSED_VARIABLE",
 "USELESS_CAST",
 "VARIABLE_IN_SINGLETON_WITHOUT_THREAD_LOCAL",
 "VARIABLE_WITH_REDUNDANT_INITIALIZER",
 "REDUNDANT_ELSE_IN_WHEN")

package j2kt

import javaemul.lang.*
import java.lang.IndexOutOfBoundsException
import java.lang.RuntimeException
import java.util.AbstractCollection
import java.util.AbstractList
import javaemul.lang.JavaAbstractMap
import javaemul.lang.JavaMap
import kotlin.Any
import kotlin.Boolean
import kotlin.Int
import kotlin.OptIn
import kotlin.String
import kotlin.Suppress
import kotlin.collections.Collection
import kotlin.collections.Map
import kotlin.collections.MutableCollection
import kotlin.collections.MutableIterator
import kotlin.collections.MutableList
import kotlin.collections.MutableMap
import kotlin.collections.MutableMap.MutableEntry
import kotlin.collections.MutableSet
import kotlin.experimental.ExperimentalObjCName
import kotlin.jvm.JvmStatic
import kotlin.native.ObjCName

@ObjCName("J2ktJ2ktCollections", exact = true)
open class Collections {
 @ObjCName("J2ktJ2ktCollectionsCompanion", exact = true)
 companion object {
  @JvmStatic
  @ObjCName("testCollection_generic")
  fun <T> testCollection_generic(
   @ObjCName("withJavaUtilCollection") collection: MutableCollection<T>
  ) {
   collection.java_contains(Collections.generic<T>())
   collection.java_remove(Collections.generic<T>())
   collection.java_containsAll(Collections.genericCollection<T>())
   collection.java_addAll(Collections.genericCollection<T>())
   collection.java_removeAll(Collections.genericCollection<T>())
   collection.java_retainAll(Collections.genericCollection<T>())
   collection.java_contains(Collections.mismatching() as Any?)
   collection.java_remove(Collections.mismatching() as Any?)
   collection.java_containsAll(Collections.mismatchingCollection())
   collection.java_removeAll(Collections.mismatchingCollection())
   collection.java_retainAll(Collections.mismatchingCollection())
  }

  @JvmStatic
  @ObjCName("testCollection_parameterized")
  fun testCollection_parameterized(
   @ObjCName("withJavaUtilCollection") collection: MutableCollection<String>
  ) {
   collection.java_contains(Collections.string())
   collection.java_remove(Collections.string())
   collection.java_containsAll(Collections.collectionOfString())
   collection.java_addAll(Collections.collectionOfString())
   collection.java_removeAll(Collections.collectionOfString())
   collection.java_retainAll(Collections.collectionOfString())
   collection.java_contains(Collections.mismatching() as Any?)
   collection.java_remove(Collections.mismatching() as Any?)
   collection.java_containsAll(Collections.mismatchingCollection())
   collection.java_removeAll(Collections.mismatchingCollection())
   collection.java_retainAll(Collections.mismatchingCollection())
  }

  @JvmStatic
  @ObjCName("testCollection_specialized")
  fun testCollection_specialized(
   @ObjCName("withJ2ktCollections_CollectionOfString") collection: Collections.CollectionOfString
  ) {
   collection.java_contains(Collections.string())
   collection.java_remove(Collections.string())
   collection.java_containsAll(Collections.collectionOfString())
   collection.java_addAll(Collections.collectionOfString())
   collection.java_removeAll(Collections.collectionOfString())
   collection.java_retainAll(Collections.collectionOfString())
   collection.java_contains(Collections.mismatching() as Any?)
   collection.java_remove(Collections.mismatching() as Any?)
   collection.java_containsAll(Collections.mismatchingCollection())
   collection.java_removeAll(Collections.mismatchingCollection())
   collection.java_retainAll(Collections.mismatchingCollection())
  }

  @JvmStatic
  @ObjCName("testList_generic")
  fun <T> testList_generic(
   @ObjCName("withJavaUtilList") list: MutableList<T>
  ) {
   list.java_addAll(0, Collections.genericCollection<T>())
   list.java_indexOf(Collections.generic<T>())
   list.java_lastIndexOf(Collections.generic<T>())
   list.java_indexOf(Collections.mismatching() as Any?)
   list.java_lastIndexOf(Collections.mismatching() as Any?)
  }

  @JvmStatic
  @ObjCName("testList_parameterized")
  fun testList_parameterized(
   @ObjCName("withJavaUtilList") list: MutableList<String>
  ) {
   list.java_addAll(0, Collections.collectionOfString())
   list.java_indexOf(Collections.string())
   list.java_lastIndexOf(Collections.string())
   list.java_indexOf(Collections.mismatching() as Any?)
   list.java_lastIndexOf(Collections.mismatching() as Any?)
  }

  @JvmStatic
  @ObjCName("testList_specialized")
  fun testList_specialized(
   @ObjCName("withJ2ktCollections_ListOfString") list: Collections.ListOfString
  ) {
   list.java_addAll(0, Collections.collectionOfString())
   list.java_indexOf(Collections.string())
   list.java_lastIndexOf(Collections.string())
   list.java_indexOf(Collections.mismatching() as Any?)
   list.java_lastIndexOf(Collections.mismatching() as Any?)
  }

  @JvmStatic
  @ObjCName("testMap_generic")
  fun <K, V> testMap_generic(
   @ObjCName("withJavaUtilMap") map: MutableMap<K, V>
  ) {
   map.java_get(Collections.generic<K>())
   map.java_getOrDefault(Collections.generic<K>(), Collections.generic<V?>())
   map.java_containsKey(Collections.generic<K>())
   map.java_containsValue(Collections.generic<V>())
   map.java_putAll(Collections.genericMap<K, V>())
   map.java_remove(Collections.generic<K>())
   map.java_remove(Collections.generic<K>(), Collections.generic<V>())
   map.java_get(Collections.mismatching() as Any?)
   map.java_getOrDefault(Collections.mismatching() as Any?, Collections.generic<V?>())
   map.java_containsKey(Collections.mismatching() as Any?)
   map.java_containsValue(Collections.mismatching() as Any?)
   map.java_remove(Collections.mismatching() as Any?)
   map.java_remove(Collections.mismatching() as Any?, Collections.mismatching() as Any?)
  }

  @JvmStatic
  @ObjCName("testMap_parameterized")
  fun testMap_parameterized(
   @ObjCName("withJavaUtilMap") map: MutableMap<String, String>
  ) {
   map.java_get(Collections.string())
   map.java_getOrDefault(Collections.string(), Collections.string())
   map.java_containsKey(Collections.string())
   map.java_containsValue(Collections.string())
   map.java_putAll(Collections.mapOfString())
   map.java_remove(Collections.string())
   map.java_remove(Collections.string(), Collections.string())
   map.java_get(Collections.mismatching() as Any?)
   map.java_getOrDefault(Collections.mismatching() as Any?, Collections.string())
   map.java_containsKey(Collections.mismatching() as Any?)
   map.java_containsValue(Collections.mismatching() as Any?)
   map.java_remove(Collections.mismatching() as Any?)
   map.java_remove(Collections.mismatching() as Any?, Collections.mismatching() as Any?)
  }

  @JvmStatic
  @ObjCName("testMap_specialized")
  fun testMap_specialized(
   @ObjCName("withJ2ktCollections_MapOfString") map: Collections.MapOfString
  ) {
   map.java_get(Collections.string())
   map.java_getOrDefault(Collections.string(), Collections.string())
   map.java_containsKey(Collections.string())
   map.java_containsValue(Collections.string())
   map.java_putAll(Collections.mapOfString())
   map.java_remove(Collections.string())
   map.java_remove(Collections.string(), Collections.string())
   map.java_get(Collections.mismatching() as Any?)
   map.java_getOrDefault(Collections.mismatching() as Any?, Collections.string())
   map.java_containsKey(Collections.mismatching() as Any?)
   map.java_containsValue(Collections.mismatching() as Any?)
   map.java_remove(Collections.mismatching() as Any?)
   map.java_remove(Collections.mismatching() as Any?, Collections.mismatching() as Any?)
  }

  @JvmStatic
  private fun <T> convert(`object`: T): T {
   return `object`
  }

  @JvmStatic
  private fun <T> convertCollection(c: MutableCollection<T>): MutableCollection<T> {
   return c
  }

  @JvmStatic
  private fun <K, V> convertMap(m: MutableMap<K, V>): MutableMap<K, V> {
   return m
  }

  @JvmStatic
  private fun <T> generic(): T {
   throw RuntimeException()
  }

  @JvmStatic
  private fun string(): String {
   throw RuntimeException()
  }

  @JvmStatic
  private fun mismatching(): Int {
   throw RuntimeException()
  }

  @JvmStatic
  private fun <T> genericCollection(): MutableCollection<T> {
   throw RuntimeException()
  }

  @JvmStatic
  private fun collectionOfString(): MutableCollection<String> {
   throw RuntimeException()
  }

  @JvmStatic
  private fun mismatchingCollection(): MutableCollection<Int> {
   throw RuntimeException()
  }

  @JvmStatic
  private fun <K, V> genericMap(): MutableMap<K, V> {
   throw RuntimeException()
  }

  @JvmStatic
  private fun mapOfString(): MutableMap<String, String> {
   throw RuntimeException()
  }
 }

 @ObjCName("J2ktJ2ktCollections_CustomCollection", exact = true)
 open class CustomCollection<T>: AbstractCollection<T>() {
  override fun iterator(): MutableIterator<T> {
   throw RuntimeException()
  }

  override val size: Int
   get() {
    return 0
   }

  override fun contains(o: T): Boolean {
   var o_1: Any? = o
   o_1 = Collections.convert<Any?>(o_1)
   return super<AbstractCollection>.contains(o_1 as T)
  }

  override fun remove(o: T): Boolean {
   var o_1: Any? = o
   o_1 = Collections.convert<Any?>(o_1)
   return super<AbstractCollection>.remove(o_1 as T)
  }

  override fun addAll(c: Collection<T>): Boolean {
   var c_1: MutableCollection<out T> = c as MutableCollection<out T>
   c_1 = Collections.convertCollection(c_1)
   return super<AbstractCollection>.addAll(c_1 as Collection<T>)
  }

  override fun containsAll(c: Collection<T>): Boolean {
   var c_1: MutableCollection<*> = c as MutableCollection<*>
   c_1 = Collections.convertCollection(c_1)
   return super<AbstractCollection>.containsAll(c_1 as Collection<T>)
  }

  override fun removeAll(c: Collection<T>): Boolean {
   var c_1: MutableCollection<*> = c as MutableCollection<*>
   c_1 = Collections.convertCollection(c_1)
   return super<AbstractCollection>.removeAll(c_1 as Collection<T>)
  }

  override fun retainAll(c: Collection<T>): Boolean {
   var c_1: MutableCollection<*> = c as MutableCollection<*>
   c_1 = Collections.convertCollection(c_1)
   return super<AbstractCollection>.retainAll(c_1 as Collection<T>)
  }
 }

 @ObjCName("J2ktJ2ktCollections_CustomList", exact = true)
 open class CustomList<T>: AbstractList<T>() {
  override fun get(index: Int): T {
   throw IndexOutOfBoundsException()
  }

  override val size: Int
   get() {
    return 0
   }

  override fun addAll(index: Int, c: Collection<T>): Boolean {
   var c_1: MutableCollection<out T> = c as MutableCollection<out T>
   c_1 = Collections.convertCollection(c_1)
   return super<AbstractList>.addAll(index, c_1 as Collection<T>)
  }

  override fun indexOf(o: T): Int {
   var o_1: Any? = o
   o_1 = Collections.convert<Any?>(o_1)
   return super<AbstractList>.indexOf(o_1 as T)
  }

  override fun lastIndexOf(o: T): Int {
   var o_1: Any? = o
   o_1 = Collections.convert<Any?>(o_1)
   return super<AbstractList>.lastIndexOf(o_1 as T)
  }
 }

 @ObjCName("J2ktJ2ktCollections_CustomMap", exact = true)
 open class CustomMap<K, V>: JavaAbstractMap<K, V>() {
  override val entries: MutableSet<MutableEntry<K, V>>
   get() {
    throw RuntimeException()
   }

  override fun containsKey(key: K): Boolean {
   var key_1: Any? = key
   key_1 = Collections.convert<Any?>(key_1)
   return super<JavaAbstractMap>.containsKey(key_1 as K)
  }

  override fun containsValue(value: V): Boolean {
   var value_1: Any? = value
   value_1 = Collections.convert<Any?>(value_1)
   return super<JavaAbstractMap>.containsValue(value_1 as V)
  }

  override fun remove(key: K): V? {
   var key_1: Any? = key
   key_1 = Collections.convert<Any?>(key_1)
   return super<JavaAbstractMap>.remove(key_1 as K)
  }

  override fun remove(key: K, value: V): Boolean {
   var value_1: Any? = value
   var key_1: Any? = key
   key_1 = Collections.convert<Any?>(key_1)
   value_1 = Collections.convert<Any?>(value_1)
   return super<JavaAbstractMap>.remove(key_1 as K, value_1 as V)
  }

  override fun get(key: K): V? {
   var key_1: Any? = key
   key_1 = Collections.convert<Any?>(key_1)
   return super<JavaAbstractMap>.get(key_1 as K)
  }

  override fun java_getOrDefault(key: Any?, defaultValue: V?): V? {
   var key_1: Any? = key
   key_1 = Collections.convert<Any?>(key_1)
   return super<JavaAbstractMap>.java_getOrDefault(key_1, defaultValue)
  }

  override fun putAll(m: Map<out K, V>) {
   var m_1: MutableMap<out K, out V> = m as MutableMap<out K, out V>
   m_1 = Collections.convertMap(m_1)
   super<JavaAbstractMap>.putAll(m_1 as Map<out K, V>)
  }
 }

 @ObjCName("J2ktJ2ktCollections_CustomMap2", exact = true)
 abstract class CustomMap2<K, V>: Collections.CustomMap<K, V>(), JavaMap<K, V> {
  override fun remove(key: K, value: V): Boolean {
   val value_1: Any? = value
   val key_1: Any? = key
   return super<Collections.CustomMap>.remove(key_1 as K, value_1 as V)
  }

  override fun java_getOrDefault(arg0: Any?, arg1: V?): V? {
   return super<Collections.CustomMap>.java_getOrDefault(arg0, arg1)
  }
 }

 @ObjCName("J2ktJ2ktCollections_CollectionOfString", exact = true)
 open class CollectionOfString: Collections.CustomCollection<String>() {
  @ObjCName("containsInteger")
  open fun containsInteger(
   @ObjCName("withJavaLangInteger") integer: Int
  ): Boolean {
   return super<Collections.CustomCollection>.remove(integer as String)
  }

  @ObjCName("removeInteger")
  open fun removeInteger(
   @ObjCName("withJavaLangInteger") integer: Int
  ): Boolean {
   return super<Collections.CustomCollection>.remove(integer as String)
  }
 }

 @ObjCName("J2ktJ2ktCollections_ListOfString", exact = true)
 open class ListOfString: Collections.CustomList<String>() {
  override fun indexOf(o: String): Int {
   var o_1: Any? = o
   o_1 = Collections.convert<Any?>(o_1)
   return super<Collections.CustomList>.indexOf(o_1 as String)
  }

  override fun lastIndexOf(o: String): Int {
   var o_1: Any? = o
   o_1 = Collections.convert<Any?>(o_1)
   return super<Collections.CustomList>.lastIndexOf(o_1 as String)
  }
 }

 @ObjCName("J2ktJ2ktCollections_MapOfString", exact = true)
 open class MapOfString: Collections.CustomMap<String, String>() {
  override fun containsKey(key: String): Boolean {
   var key_1: Any? = key
   key_1 = Collections.convert<Any?>(key_1)
   return super<Collections.CustomMap>.containsKey(key_1 as String)
  }

  override fun containsValue(value: String): Boolean {
   var value_1: Any? = value
   value_1 = Collections.convert<Any?>(value_1)
   return super<Collections.CustomMap>.containsValue(value_1 as String)
  }

  override fun remove(key: String): String? {
   var key_1: Any? = key
   key_1 = Collections.convert<Any?>(key_1)
   return super<Collections.CustomMap>.remove(key_1 as String)
  }

  override fun remove(key: String, value: String): Boolean {
   var value_1: Any? = value
   var key_1: Any? = key
   key_1 = Collections.convert<Any?>(key_1)
   value_1 = Collections.convert<Any?>(value_1)
   return super<Collections.CustomMap>.remove(key_1 as String, value_1 as String)
  }

  override fun get(key: String): String? {
   var key_1: Any? = key
   key_1 = Collections.convert<Any?>(key_1)
   return super<Collections.CustomMap>.get(key_1 as String)
  }

  override fun java_getOrDefault(key: Any?, defaultValue: String?): String? {
   var key_1: Any? = key
   key_1 = Collections.convert<Any?>(key_1)
   return super<Collections.CustomMap>.java_getOrDefault(key_1, defaultValue)
  }
 }
}
